#+TITLE: org-mode-connection

This package allows to read, write and sync emacs's org-mode files.

It was developed as foundation for [[https://github.com/bnankiewicz/organic][organic]] - mobile org-mode client written in React Native.

It is designed to work both in mobile and server/desktop environments.

* Installation

#+BEGIN_SRC sh
cd /tmp
yarn add realm promisify-node org-mode-connection
#+END_SRC

* Configuration

** with Node.js

#+name: setup
 #+BEGIN_SRC js :results output
var OrgApi = require('org-mode-connection').OrgApi
const realm = require('realm')
const promisify = require("promisify-node");
const fsInterface = promisify("fs")
OrgApi.configureFileAccess(fsInterface);
OrgApi.configureDb(realm);
OrgApi.connectDb();
 #+END_SRC


** with React Native
#+BEGIN_SRC javascript
import OrgApi from 'org-mode-connection';
import RNFS from 'react-native-fs';
import Realm from 'realm';

// Configure
OrgApi.configureFileAccess(RNFS);
OrgApi.configureDb(Realm);
OrgApi.connectDb();
#+END_SRC

* Usage
#+BEGIN_SRC js :results output :noweb yes
<<setup>>
const query =  async() => {
    // Configure
    // await OrgApi.clearDb()
    // await OrgApi.addFile('/home/keenan/Chaos/js.org')
    // await OrgApi.syncDb()
    const x = await OrgApi.getAllFilesAsPlainObject()
    console.log(x)
    // OrgApi.clearDb()
    process.exit()
}
query()
#+END_SRC

* Types
** PlainOrgNode
** PlainOrgFile
** InsertPosition
** Realm
** FsInterface
** PlainAgenda
** TimeRange
** ExternalFileChange
** Tocs
** SearchQuery
* Typedoc tools                                                    :noexport:

** setup
#+name: imports
#+BEGIN_SRC js :result output :noweb yes
var R = require('ramda')
#+END_SRC
** doc to org
#+name: typedoc-tools
#+BEGIN_SRC js :result output :noweb yes
<<imports>>
const link = (o) => {
    if (['Promise', 'Object'].includes(o)) return o
  return `[[${o}][${o}]]`
}

const renderType = (o) => {
    //console.log(o)

    if (o.kindString === 'Variable') return `${o.name}: ${renderType(o.type)}`
    if (o.kindString === 'Type literal') return `{ ${o.children.map(renderType).join(', ')} }`
    if (o.type === 'array') return `${renderType(o.elementType)}[]`
    if (o.type === 'intrinsic') return `/${o.name}/`
    if (o.type === 'reference') {
        let typeArguments = ''
        typeArguments = o.typeArguments ? `< ${o.typeArguments.map(renderType)} >` : ''
        return `${link(o.name)}${typeArguments}`
    }
    if (o.type === 'reflection') {
        return renderType(o.declaration)
    }
}

const renderReturnType = (o) => {
    //console.log(renderType(o.signatures[0].type))
    return renderType(o.signatures[0].type)
}

const renderHeadline = (o) => {
    if (o.kindString === 'Interface') return `${o.name} interface`
    if (o.kindString === 'Type alias') return `${o.name} type`
    if (o.kindString === 'Variable') return `${o.name} interface`
    return `** ${o.name}(${renderParametersShort(o)}): ${renderReturnType(o)}` }

const renderParameter = (p) => {
    const text = p.comment.text
    const comment = (text && text.trim() !== '') ? `- ${text.trim()}` : ''
    return `- *${p.name}*: ${renderType(p.type)} ${comment}`
}

const renderParameterInline = (p) => {
    //console.log(p)
    return `/${p.name}/`
}
const renderSignature = (o) => {
    // console.log(o)
    return [getComment(o), renderParametersLong(o)].join('\n')
}
const pr = (x) => R.tap(console.log(x))

const getComment = R.pipe(
    R.prop('signatures'),
    R.head,
    R.path(['comment', 'shortText']),
)
const renderParameters = type => R.pipe(
    R.prop('signatures'),
    R.head,
    R.prop('parameters'),
    R.unless(R.isNil, R.pipe(
        R.map(type === 'long' ? renderParameter : renderParameterInline),
        R.join(type === 'long' ? '\n' : ', '),
        R.when(() => type==='long' ,R.concat(R.__, '\n')))),
    R.when(R.isNil, () => '')
)

const renderParametersLong = renderParameters('long')
const renderParametersShort = renderParameters('short')

const getChild = (name) => R.pipe(R.prop('children'), R.find(R.propEq('name', name)))

const asOrg = (l) => [
    renderHeadline(l),
    getComment(l),
    renderParametersLong(l),
].join('\n')

const asObj = (l) => l

console.log('* Api')
const printLines = render => lines => {
    lines.forEach(l => console.log(render(l)))
}
#+END_SRC

#+RESULTS: typedoc-tools
: undefined
* Api docs generator                                               :noexport:
#+BEGIN_SRC js :results output raw replace :noweb yes
<<typedoc-tools>>
const f = require('/home/keenan/Chaos/documentation.json')

const exportedFuncs = R.pipe(
    getChild('"index.d"'),
    getChild('org_mode_connection'),
    R.path(['type', 'declaration']),
    getChild('OrgApi'),
    R.path(['type', 'declaration', 'children']),
)(f)

printLines(asOrg)(exportedFuncs)
#+END_SRC

#+RESULTS:
* Api
** addFile(/title/): Promise< /void/ >
Creates empty file in database.
- *title*: /string/ - New file title

** addNodes(/nodes/, /insertPosition/, /externalChange/, /returnAddedNodes/): Promise< [[PlainOrgNode][PlainOrgNode]][] >
Add nodes to the tree of nodes
- *nodes*: [[PlainOrgNode][PlainOrgNode]][]
- *insertPosition*: [[InsertPosition][InsertPosition]]
- *externalChange*: /boolean/
- *returnAddedNodes*: /boolean/

** clearDb(): Promise< /void/ >
Clears Database.

** configureDb(/realm/): /void/
Configure database.
- *realm*: [[Realm][Realm]] - Realm object

** configureFileAccess(/fsIterface/): /void/

- *fsIterface*: [[FsInterface][FsInterface]] - Promisified file access interface

** connectDb(): Promise< /void/ >
Connect database

** createFileFromString(/name/, /lines/): Promise< /void/ >
Create file from array of strings.
- *name*: /string/ - The name of new file
- *lines*: /string/[] - List of string raw lines

** deleteFileById(/fileId/): Promise< /void/ >
Delete file from database.
- *fileId*: /string/ - File id

** deleteNodeById(/nodeId/): Promise< /void/ >
Deletes node.
- *nodeId*: /string/

** getAgendaAsPlainObject(/timeRange/, /defaultWarningPeriod/): Promise< [[PlainAgenda][PlainAgenda]] >
Returns agenda as plain object
- *timeRange*: [[TimeRange][TimeRange]]
- *defaultWarningPeriod*: /number/

** getAllFilesAsPlainObject(): [[PlainOrgFile][PlainOrgFile]][]
Returns all OrgFiles as plain objects

** getAncestorsAsPlainObject(/nodeId/): Promise< [[PlainOrgNode][PlainOrgNode]][] >
Returns all ancestors of node.
- *nodeId*: /string/

** getExternallyChangedFiles(): Promise< [[ExternalFileChange][ExternalFileChange]][] >
Returns ids of externally changed files

** getFileAsPlainObject(/id/): Promise< [[PlainOrgFile][PlainOrgFile]] >
Returns file and its nodes data as plain object.
- *id*: /string/ - File id

** getObjects(/model/, /filter/): Promise< [[RealmResults][RealmResults]] >
Return raw RealmResults object
- *model*: undefined - Realm model
- *filter*: /string/ - Realm filter string

** getOrCreateNodeByHeadline(/targedNode/): Promise< [[PlainOrgNode][PlainOrgNode]] >
Gets node by headline. If node doasnt exists it is created.
- *targedNode*: { fileId: /string/, headline: /string/ }

** getRelatedNodes(/nodeId/): Promise< [[PlainOrgNode][PlainOrgNode]][] >
Returns ancestors and descendants
- *nodeId*: /string/

** getTagsAsPlainObject(): Promise< /string/[] >
Returns list of all tags

** getTocs(): Promise< [[Tocs][Tocs]] >
Returns all files with their child nodes

** importFile(/filepath/): Promise< /void/ >
Imports external file
- *filepath*: /string/

** search(/searchQuery/): Promise< /any/ >
Search
- *searchQuery*: [[SearchQuery][SearchQuery]]

** syncDb(): Promise< /any/ >
Sync all files

** syncFile(/id/): Promise< /any/ >
Syncs file
- *id*: /any/ - file id

** updateFile(/id/, /changes/): Promise< /any/ >
Merges prop to file object
- *id*: /string/ - File id
- *changes*: Object - New file props to merge

** updateNodeById(/id/, /changes/): Promise< /any/ >
Merges props to node object
- *id*: /string/ - Node id
- *changes*: Object - New node props to merge
* License

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
